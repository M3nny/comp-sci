Linguaggi di programmazione possono essere **unsafe**, soprattutto quelli di basso di livello, vedremo ora come scrivere programmi sicuri in C.

Esistono standard come l'[ISO/IEC TS 17961:](https://www.iso.org/standard/61134.html) e raccomandazioni come [SEI CERT C Coding Standard](https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard) i quali forniscono una guida su come scrivere codice ritenuto sicuro.

Esistono tool per l'**analisi statica** dei programmi i quali riportano difetti nel codice, alcune volte però accadono:
- **Falsi negativi**: non segnalano difetti esistenti
- **Falsi positivi**: segnalano difetti non esistenti


| Falsi negativi\Falsi positivi | No                          | Si                      |
| ----------------------------- | --------------------------- | ----------------------- |
| **No**                        | Sano e completo             | Sano con falsi positivi |
| **Si**                        | Completo con falsi negativi | Non sano e incompleto   |

### Taint analysis
L'**analisi della contaminazione** (taint) valuta gli input dell'utente e come possono influenzare i valori nel programma durante un'operazione rischiosa.
- **Tained source**: qualsiasi fonte di dati esterna che può essere controllata da un attaccante
- **Tained value**: valore derivante o computato da una _tained source_ che non è stato sanificato
- **Restricted sink**: un argomento di una funzione che richiede di essere in un dominio ristretto (e.g. le stringhe devono terminare con `0x00` altrimenti chi le legge può accedere alla memoria seguente)

### Taint propagation
Una contaminazione è propagata dagli operandi ai risultati a meno che l'operazione stessa non imponga vincoli sul valore del suo risultato.
```c
strcpy(s1, s2) // se s2 è contaminata, allora anche s1 lo sarà
```

La propagazione può essere complessa, in quanto una contaminazione di un tipo può propagarsi come una contaminazione di un tipo differente (e.g. `strlen()` nel caso in cui la stringa non sia null-terminated).
```c
// c contaminato
for (int i = 0; i < MAX && (c = getchar()) != EOF; i++)
	buffer[i] = c // buffer contaminato
len = strlen(buffer) // len contaminato
for (int i = 0; i < len; i++)
	// computazione del buffer contaminata
```

### Sanificazione
È possibile rimuovere la contaminazione tramite due approcci principali:
- **Sostituzione**: i valori che vanno fuori dal dominio vengono sostituiti da valori dentro al dominio
- **Terminazione**: dopo avere individuato un valore fuori dal dominio, il programma termina o salta la parte di codice che riguarda il valore contaminato

---
## Valutazione del rischio
La valutazione del rischio è un'indicazione di:
- **Potenziali conseguenze** del non affrontare una particolare guida
- I **costi di rimedio** previsti

Viene utilizzata per dare **priorità** alla riparazione di una violazione delle norme.
Ogni regola e raccomandazione ha una _priorità_ assegnata la quale è composta da tre valori con una scala da 1 a 3:
- **Severità**
- **Probabilità**
- **Costo di rimedio**

### Severità
Quanto sono **preoccupanti** le **conseguenze** della regola ignorata?

| Valore | Significato | Esempio di vulnerabilità                                         |
| ------ | ----------- | ---------------------------------------------------------------- |
| 1      | Basso       | Attacco denial-of-service, terminazione anomala                  |
| 2      | Medio       | Violazione dell'integrità dei dati, divulgazione di informazioni |
| 3      | Alto        | Esecuzione di codice arbitrario                                  |

### Probabilità
Quanto è probabile che un difetto introdotto violando una regola possa portare ad una **vulnerabilità sfruttabile**?

| Valore | Significato     |
| ------ | --------------- |
| 1      | Poco probabile  |
| 2      | Probabile       |
| 3      | Molto probabile |

### Costo di rimedio
Quanto è **costoso** rispettare la norma?

| Valore | Significato | Rilevamento | Correzione |
| ------ | ----------- | ----------- | ---------- |
| 1      | Alto        | Manuale     | Manuale    |
| 2      | Medio       | Automatico  | Manuale    |
| 3      | Basso       | Automatico  | Automatico |
>Basso ha un valore più alto perchè vanno prima sistemati i problemi meno costosi.

I valori vanno poi moltiplicati tra loro per ottenere **tre livelli di priorità**:
![[Livelli di priorità.png]]

**Out-of-bounds pointers**: può risultare in un buffer overflow (_severità alta_), è _molto probabile_ che l'overflow venga sfruttato e non può essere rilevato automaticamente in molti casi, per cui ci sono _alti costi_ di rimedio.

| Severità | Probabilità     | Costo di rimedio | Priorità | Livello |
| -------- | --------------- | ---------------- | -------- | ------- |
| Alta     | Molto probabile | Alto             | P9       | L2      |

**Non-null-terminated character sequence**: può risultare in un buffer overflow (_severità alta_), la vulnerabilità dipende dal contesto, è _probabile_ che venga sfruttata e può essere rilavata automaticamente in molti casi (_medi costi_ di rimedio).

| Severità | Probabilità | Costo di rimedio | Priorità | Livello |
| -------- | ----------- | ---------------- | -------- | ------- |
| Alta     | Probabile   | Medio            | P12      | L1      |

**Altre norme** sono:
Garantire che una stringa sia allocata in uno spazio sufficiente per i suoi caratteri ed il terminatore null.

Usare funzioni che controllano i limiti del buffer durante la manipolazione delle stringhe, tra cui:
- `strcpy(dst, src)` dove `dst` deve essere largo abbastanza per evitare overflow
- `strncpy(dst, src, n)` copia al massimo `n` byte da `src` (se non c'è `0x00` nei primi `n` bytes la stringa non sarà null-terminated)
- BSD offre opzioni come `strlcpy(dst, src, n)` la quale copia al massimo `n-1` byte da `src` e aggiunge sempre un byte `0x00` alla fine

Non chiamare la funzione `system()` in quanto potrebbe portare a vulnerabilità sfruttabili, tra cui:
- Passare una stringa non sanificata proveniente da una fonte contaminata
- Il comando è eseguito senza una path specifico
- Viene specificato un path relativo
- L'eseguibile specificato potrebbe essere falsificato (spoofed)
